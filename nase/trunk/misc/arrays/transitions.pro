;+
; NAME:
;  Transitions()
;
; VERSION:
;  $Id$
;
; AIM:
;  Generate random sequence of array entries.
;
; PURPOSE:
;  <C>Transitions</C> generates a random sequence of array entries
;  that contains all possible transitions between the entries of the
;  array. This may be needed to create stimulations that switch
;  between a number of possible states and one wants to be sure that
;  all these states are visited and that at the same time all
;  transitions from one of these states to another one are also
;  contained. Since there may be more than one solution to this
;  problem, <C>Transitions</C> generates one possible random
;  solution. If one needs longer sequences, different of those random
;  transition sequences may be concatenated.
;
; CATEGORY:
;  Array
;  CombinationTheory
;  Input
;  Signals
;
; CALLING SEQUENCE:
;* result = Transitions(array)
;
; INPUTS:
;  array:: Onedimensional array of numerical or string type. Arrays of
;          higher dimension may be passed to <C>Transitions()</C>, but
;          they are interpreted as onedimensional. Transitions between
;          multidimensional array entries can easily be generated by using the
;          onedim sequence as an index to one dimension of a higher
;          dimensional array. 
;
; OUTPUTS:
;  result:: Onedimensional array containing a sequence of
;           all of <*>array</*>'s
;           entries. <*>result[0]=Last(result)=array[0]</*>, ie the
;           sequence always starts and ends with the input array's
;           first entry. The number of elements in <*>result</*> is
;           <*>n*(n-1)+1</*> with <*>n</*> being the number of entries
;           in <*>array</*>.
;
; COMMON BLOCKS:
;  random
;
; PROCEDURE:
;  Genereta a series of array indices starting from the basic
;  transition <*>0->1->0</*> for a two element array. Successively insert
;  more states for longer arrays by replacing a randomly chosen index
;  with a transition from this index to a new one and than back (eg
;  replace first <*>0</*> in the basic sequence with <*>0->2->0</*> yielding
;  <*>0->2->0->1->0</*>) and so on. Finally, use this sequence as indices to
;  the original array. 
;
; EXAMPLE:
;* array=['a','b','c']
;* print, transitions(array)
;*> a b c b a c a
;* print, transitions(array)
;*> a c a b c b a
;
; SEE ALSO:
;  <A>FracRandom()</A>
;-

FUNCTION Transitions, array

   COMMON random, seed

   length = N_Elements(array)
   final = length-1

   ;; basic transition for array with 2 elements
   t = [0, 1, 0]

   ;; successively add more transitions
   FOR next=2, final DO BEGIN
      ;; next contains new state 
      FOR i=0, next-1 DO BEGIN
         ;; find first place where new state would fit
;         idx = (Where(t EQ i))[0]
         ;; find all places where new state would fit and choose one randomly
         allidx = Where(t EQ i, count)
         idx = allidx[count*RandomU(seed)]
         ;; add new state
         t = [t[0:idx], next, t[idx:*]]
      ENDFOR
   ENDFOR 
   
   ;; interpret sequence of transitions as array indices 
   Return, array[t]

END
