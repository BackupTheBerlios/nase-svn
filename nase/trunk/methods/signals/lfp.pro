;+
; NAME:                LFP
;
; PURPOSE:             Computes LFP-signals similar to those got by
;                      micro-electrode recordings. You can choose
;                      various recording positions. The signals are
;                      generated by collecting membrane potential 
;                      for the neurons neighbors with spatially
;                      decaying weights. The result should be 
;                      bandpass filtered with the filter routine.
;
; CATEGORY:            STAT SIGNAL
;
; CALLING SEQUENCE:    LFPS = LFP( mt, recSites { ,CONST=const | ,HMW_X2=xmw_x2 } [,ROI=roi] [,/NASE] )
;
; INPUTS:              mt      : 3d-array, containung the temporal
;                                development of the membrane potentials (height, width, time)
;                      recSites: a list of recording positions [[x1,y1],[x2,y2],..]
;
; KEYWORD PARAMETERS:  CONST   : constant weighing  (=1) of all
;                                membrane potentials with a maximal distance of CONST from the
;                                recording position
;                      HMW_X2  : quadratic decay of potentials with a
;                                half mean width of HMW_X2
;                      NASE    : correct handling of nase layers
;                       
; OPTIONAL OUTPU       ROI     : contains the weight matrix for each
;                                region of interest (signal_nr,height, 
;                                width)
;
; OUTPUTS:             LFPS  : array (index, time) containing the lfp signals
;
; EXAMPLE:
;                      mt = 5+RandomN(seed,10,10,1000)
;                      LFPS = LFP(mt, [[0,0], [5,5]], HMW_X2=2)
;                      plot, REFORM(LFPS(0,*))
;                      oplot, REFORM(LFPS(1,*))-50., LINESTYLE=2                      
;    
; MODIFICATION HISTORY:
;
;     $Log$
;     Revision 1.10  2000/03/27 14:08:01  saam
;           updated and translated doc header
;
;     Revision 1.9  1999/07/28 08:54:37  saam
;           erased frange and sample_t again, use filter instead,
;           i'm afraid its getting kitchen sink
;
;     Revision 1.8  1999/02/02 19:10:54  saam
;           + now uses 'filter' for bandpass-filtering
;           + new keyword FRANGE to change the filtering
;             behaviour
;
;     Revision 1.7  1998/07/11 12:07:58  saam
;           new keyword SAMPLE_T for correct handling
;           of different smapled signals
;
;     Revision 1.6  1998/05/28 12:33:05  saam
;           Keyword NASE added
;
;     Revision 1.5  1998/05/18 19:45:55  saam
;           problems with nase layers corrected by new keyword NASE
;
;     Revision 1.4  1998/04/01 17:35:09  saam
;           only two recording sites were handled
;           corrected -> now it hopefully with 1..n
;
;     Revision 1.3  1998/04/01 16:19:03  saam
;           now also a single region of interest
;           is investigated (small bug)
;
;     Revision 1.2  1998/03/04 09:34:59  saam
;           new keyword ROI
;
;     Revision 1.1  1998/03/03 19:03:14  saam
;           a birth
;
;
;-
FUNCTION LFP, mt, list, CONST=const, HMW_X2=hmw_x2, ROI=roi, NASE=nase

   On_Error, 2

   Default, radius  , 5

   IF N_Params() NE 2 THEN Message, 'wrong number of arguments'


   mtS    = SIZE(mt)

   listS  = SIZE(list)
   IF listS(0) EQ 1 AND N_Elements(list) EQ 2 THEN BEGIN
      list = REFORM(list, 2, 1, /OVERWRITE)
      listS = SIZE(list)
   END

   maxROI = listS(2)
   maxT   = mtS(3)

   IF listS(0) NE 2 THEN Message, 'wrong format for second argument'
   IF mtS(0)   NE 3 THEN Message, 'wrong format for first argument'


   roiSigs = DblArr(maxROI, maxT)
   
   
   ; -----> GET THE INTEGRATION AREAS
   print, 'LFP: getting integration areas...'
   print, ' '
   ROI = DblArr(maxROI, mtS(1), mtS(2))
   FOR i=0, maxROI-1 DO BEGIN
      IF Set(CONST) THEN BEGIN
         print, !KEY.UP, 'LFP: using constant weighting with radius ',STRCOMPRESS(const,/REMOVE_ALL)
         tmpArr = Make_Array(mtS(1), mtS(2), /INT, VALUE=1)
         IF Keyword_Set(NASE) THEN BEGIN
            tmpArr = CutTorus(tmpArr, const, X_CENTER=list(1,i)-mtS(1)/2, Y_CENTER=list(0,i)-mtS(2)/2)
         END ELSE BEGIN
            tmpArr = CutTorus(tmpArr, const, X_CENTER=list(0,i)-mtS(1)/2, Y_CENTER=list(1,i)-mtS(2)/2) 
         END
         ROI(i,*,*) = tmpArr
      ENDIF ELSE IF Set(hmw_x2) THEN BEGIN
         print, !KEY.UP, 'LFP: using x^(-2) weighting with HMW  ',STRCOMPRESS(hmw_x2,/REMOVE_ALL)
         IF Keyword_Set(NASE) THEN BEGIN
            tmpArr = SHIFT(DIST(mtS(1), mtS(2)), list(1,i), list(0,i) )
         END ELSE BEGIN
            tmpArr = SHIFT(DIST(mtS(1), mtS(2)), list(0,i), list(1,i) )
         END
         tmpArr = 1./(HMW_X2^2)*(tmpArr^2)
         tmpArr = 1./(1.+tmpArr)
         ROI(i,*,*) = tmpArr/MAX(tmpArr)
      ENDIF ELSE Message, 'unknown integration method or no method specified'
   ENDFOR
   
   ; -----> INTEGRATE REGIONS FOR EACH TIMESTEP
   print, 'LFP: integrating potentials for '+STRCOMPRESS(maxROI,/REMOVE_ALL)+' recording site(s)'
   print, '   '
   FOR t=0l, maxT-1 DO BEGIN
      FOR i=0, maxROI-1 DO BEGIN
         roiSigs(i, t) = TOTAL( REFORM(mt(*,*,t))*REFORM(ROI(i,*,*)) )
      ENDFOR
      IF (t MOD (maxT/20)) EQ 0 THEN print, !Key.UP, 'LFP: processing... '+STRCOMPRESS(FIX(t/FLOAT(maxT)*100.), /REMOVE_ALL)+' %'
   ENDFOR
   

   ; -----> RETURN RAW SIGNALS 
   RETURN, roiSigs
END
